// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: status_update.proto

package protobuf

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type StatusUpdate_StatusType int32

const (
	StatusUpdate_UNKNOWN_STATUS_TYPE StatusUpdate_StatusType = 0
	StatusUpdate_AUTOMATIC           StatusUpdate_StatusType = 1
	StatusUpdate_DO_NOT_DISTURB      StatusUpdate_StatusType = 2
	StatusUpdate_ALWAYS_ONLINE       StatusUpdate_StatusType = 3
	StatusUpdate_INACTIVE            StatusUpdate_StatusType = 4
)

var StatusUpdate_StatusType_name = map[int32]string{
	0: "UNKNOWN_STATUS_TYPE",
	1: "AUTOMATIC",
	2: "DO_NOT_DISTURB",
	3: "ALWAYS_ONLINE",
	4: "INACTIVE",
}

var StatusUpdate_StatusType_value = map[string]int32{
	"UNKNOWN_STATUS_TYPE": 0,
	"AUTOMATIC":           1,
	"DO_NOT_DISTURB":      2,
	"ALWAYS_ONLINE":       3,
	"INACTIVE":            4,
}

func (x StatusUpdate_StatusType) String() string {
	return proto.EnumName(StatusUpdate_StatusType_name, int32(x))
}

func (StatusUpdate_StatusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_911acd91e62cd3d7, []int{0, 0}
}

// Specs:
//:AUTOMATIC
//To Send - "AUTOMATIC" status ping every 5 minutes
//Display - Online for up to 5 minutes from the last clock, after that Offline
//:ALWAYS_ONLINE
//To Send - "ALWAYS_ONLINE" status ping every 5 minutes
//Display - Online for up to 2 weeks from the last clock, after that Offline
//:INACTIVE
//To Send - A single "INACTIVE" status ping
//Display - Offline forever
//Note: Only send pings if the user interacted with the app in the last x minutes.
type StatusUpdate struct {
	Clock                uint64                  `protobuf:"varint,1,opt,name=clock,proto3" json:"clock,omitempty"`
	StatusType           StatusUpdate_StatusType `protobuf:"varint,2,opt,name=status_type,json=statusType,proto3,enum=protobuf.StatusUpdate_StatusType" json:"status_type,omitempty"`
	CustomText           string                  `protobuf:"bytes,3,opt,name=custom_text,json=customText,proto3" json:"custom_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *StatusUpdate) Reset()         { *m = StatusUpdate{} }
func (m *StatusUpdate) String() string { return proto.CompactTextString(m) }
func (*StatusUpdate) ProtoMessage()    {}
func (*StatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_911acd91e62cd3d7, []int{0}
}
func (m *StatusUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusUpdate.Merge(m, src)
}
func (m *StatusUpdate) XXX_Size() int {
	return m.Size()
}
func (m *StatusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_StatusUpdate proto.InternalMessageInfo

func (m *StatusUpdate) GetClock() uint64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *StatusUpdate) GetStatusType() StatusUpdate_StatusType {
	if m != nil {
		return m.StatusType
	}
	return StatusUpdate_UNKNOWN_STATUS_TYPE
}

func (m *StatusUpdate) GetCustomText() string {
	if m != nil {
		return m.CustomText
	}
	return ""
}

func init() {
	proto.RegisterEnum("protobuf.StatusUpdate_StatusType", StatusUpdate_StatusType_name, StatusUpdate_StatusType_value)
	proto.RegisterType((*StatusUpdate)(nil), "protobuf.StatusUpdate")
}

func init() { proto.RegisterFile("status_update.proto", fileDescriptor_911acd91e62cd3d7) }

var fileDescriptor_911acd91e62cd3d7 = []byte{
	// 274 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2e, 0x2e, 0x49, 0x2c,
	0x29, 0x2d, 0x8e, 0x2f, 0x2d, 0x48, 0x49, 0x2c, 0x49, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
	0xe2, 0x00, 0x53, 0x49, 0xa5, 0x69, 0x4a, 0x5f, 0x18, 0xb9, 0x78, 0x82, 0xc1, 0x2a, 0x42, 0xc1,
	0x0a, 0x84, 0x44, 0xb8, 0x58, 0x93, 0x73, 0xf2, 0x93, 0xb3, 0x25, 0x18, 0x15, 0x18, 0x35, 0x58,
	0x82, 0x20, 0x1c, 0x21, 0x27, 0x2e, 0x6e, 0xa8, 0x39, 0x25, 0x95, 0x05, 0xa9, 0x12, 0x4c, 0x0a,
	0x8c, 0x1a, 0x7c, 0x46, 0x8a, 0x7a, 0x30, 0x63, 0xf4, 0x90, 0x8d, 0x80, 0x72, 0x42, 0x2a, 0x0b,
	0x52, 0x83, 0xb8, 0x8a, 0xe1, 0x6c, 0x21, 0x79, 0x2e, 0xee, 0xe4, 0xd2, 0xe2, 0x92, 0xfc, 0xdc,
	0xf8, 0x92, 0xd4, 0x8a, 0x12, 0x09, 0x66, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x2e, 0x88, 0x50, 0x48,
	0x6a, 0x45, 0x89, 0x52, 0x26, 0x17, 0x17, 0x42, 0xab, 0x90, 0x38, 0x97, 0x70, 0xa8, 0x9f, 0xb7,
	0x9f, 0x7f, 0xb8, 0x5f, 0x7c, 0x70, 0x88, 0x63, 0x48, 0x68, 0x70, 0x7c, 0x48, 0x64, 0x80, 0xab,
	0x00, 0x83, 0x10, 0x2f, 0x17, 0xa7, 0x63, 0x68, 0x88, 0xbf, 0xaf, 0x63, 0x88, 0xa7, 0xb3, 0x00,
	0xa3, 0x90, 0x10, 0x17, 0x9f, 0x8b, 0x7f, 0xbc, 0x9f, 0x7f, 0x48, 0xbc, 0x8b, 0x67, 0x70, 0x48,
	0x68, 0x90, 0x93, 0x00, 0x93, 0x90, 0x20, 0x17, 0xaf, 0xa3, 0x4f, 0xb8, 0x63, 0x64, 0x70, 0xbc,
	0xbf, 0x9f, 0x8f, 0xa7, 0x9f, 0xab, 0x00, 0xb3, 0x10, 0x0f, 0x17, 0x87, 0xa7, 0x9f, 0xa3, 0x73,
	0x88, 0x67, 0x98, 0xab, 0x00, 0x8b, 0x93, 0xec, 0x89, 0x47, 0x72, 0x8c, 0x17, 0x1e, 0xc9, 0x31,
	0x3e, 0x78, 0x24, 0xc7, 0x38, 0xe3, 0xb1, 0x1c, 0x43, 0x14, 0xb7, 0x9e, 0xbe, 0x35, 0xcc, 0x3b,
	0x49, 0x6c, 0x60, 0x96, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x3a, 0x8c, 0xe9, 0xce, 0x3d, 0x01,
	0x00, 0x00,
}

func (m *StatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CustomText) > 0 {
		i -= len(m.CustomText)
		copy(dAtA[i:], m.CustomText)
		i = encodeVarintStatusUpdate(dAtA, i, uint64(len(m.CustomText)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusType != 0 {
		i = encodeVarintStatusUpdate(dAtA, i, uint64(m.StatusType))
		i--
		dAtA[i] = 0x10
	}
	if m.Clock != 0 {
		i = encodeVarintStatusUpdate(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStatusUpdate(dAtA []byte, offset int, v uint64) int {
	offset -= sovStatusUpdate(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StatusUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clock != 0 {
		n += 1 + sovStatusUpdate(uint64(m.Clock))
	}
	if m.StatusType != 0 {
		n += 1 + sovStatusUpdate(uint64(m.StatusType))
	}
	l = len(m.CustomText)
	if l > 0 {
		n += 1 + l + sovStatusUpdate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStatusUpdate(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStatusUpdate(x uint64) (n int) {
	return sovStatusUpdate(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatusUpdate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusUpdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusType", wireType)
			}
			m.StatusType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusUpdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusType |= StatusUpdate_StatusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatusUpdate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatusUpdate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatusUpdate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatusUpdate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatusUpdate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatusUpdate(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatusUpdate
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatusUpdate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatusUpdate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStatusUpdate
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStatusUpdate
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStatusUpdate
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStatusUpdate        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatusUpdate          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStatusUpdate = fmt.Errorf("proto: unexpected end of group")
)
