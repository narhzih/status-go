// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat_message.proto

package protobuf

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AudioMessage_AudioType int32

const (
	AudioMessage_UNKNOWN_AUDIO_TYPE AudioMessage_AudioType = 0
	AudioMessage_AAC                AudioMessage_AudioType = 1
	AudioMessage_AMR                AudioMessage_AudioType = 2
)

var AudioMessage_AudioType_name = map[int32]string{
	0: "UNKNOWN_AUDIO_TYPE",
	1: "AAC",
	2: "AMR",
}

var AudioMessage_AudioType_value = map[string]int32{
	"UNKNOWN_AUDIO_TYPE": 0,
	"AAC":                1,
	"AMR":                2,
}

func (x AudioMessage_AudioType) String() string {
	return proto.EnumName(AudioMessage_AudioType_name, int32(x))
}

func (AudioMessage_AudioType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{2, 0}
}

type ChatMessage_ContentType int32

const (
	ChatMessage_UNKNOWN_CONTENT_TYPE ChatMessage_ContentType = 0
	ChatMessage_TEXT_PLAIN           ChatMessage_ContentType = 1
	ChatMessage_STICKER              ChatMessage_ContentType = 2
	ChatMessage_STATUS               ChatMessage_ContentType = 3
	ChatMessage_EMOJI                ChatMessage_ContentType = 4
	ChatMessage_TRANSACTION_COMMAND  ChatMessage_ContentType = 5
	// Only local
	ChatMessage_SYSTEM_MESSAGE_CONTENT_PRIVATE_GROUP ChatMessage_ContentType = 6
	ChatMessage_IMAGE                                ChatMessage_ContentType = 7
	ChatMessage_AUDIO                                ChatMessage_ContentType = 8
	ChatMessage_COMMUNITY                            ChatMessage_ContentType = 9
	// Only local
	ChatMessage_SYSTEM_MESSAGE_GAP ChatMessage_ContentType = 10
)

var ChatMessage_ContentType_name = map[int32]string{
	0:  "UNKNOWN_CONTENT_TYPE",
	1:  "TEXT_PLAIN",
	2:  "STICKER",
	3:  "STATUS",
	4:  "EMOJI",
	5:  "TRANSACTION_COMMAND",
	6:  "SYSTEM_MESSAGE_CONTENT_PRIVATE_GROUP",
	7:  "IMAGE",
	8:  "AUDIO",
	9:  "COMMUNITY",
	10: "SYSTEM_MESSAGE_GAP",
}

var ChatMessage_ContentType_value = map[string]int32{
	"UNKNOWN_CONTENT_TYPE":                 0,
	"TEXT_PLAIN":                           1,
	"STICKER":                              2,
	"STATUS":                               3,
	"EMOJI":                                4,
	"TRANSACTION_COMMAND":                  5,
	"SYSTEM_MESSAGE_CONTENT_PRIVATE_GROUP": 6,
	"IMAGE":                                7,
	"AUDIO":                                8,
	"COMMUNITY":                            9,
	"SYSTEM_MESSAGE_GAP":                   10,
}

func (x ChatMessage_ContentType) String() string {
	return proto.EnumName(ChatMessage_ContentType_name, int32(x))
}

func (ChatMessage_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{5, 0}
}

type StickerMessage struct {
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Pack                 int32    `protobuf:"varint,2,opt,name=pack,proto3" json:"pack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StickerMessage) Reset()         { *m = StickerMessage{} }
func (m *StickerMessage) String() string { return proto.CompactTextString(m) }
func (*StickerMessage) ProtoMessage()    {}
func (*StickerMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{0}
}
func (m *StickerMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StickerMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StickerMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StickerMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StickerMessage.Merge(m, src)
}
func (m *StickerMessage) XXX_Size() int {
	return m.Size()
}
func (m *StickerMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StickerMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StickerMessage proto.InternalMessageInfo

func (m *StickerMessage) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *StickerMessage) GetPack() int32 {
	if m != nil {
		return m.Pack
	}
	return 0
}

type ImageMessage struct {
	Payload              []byte    `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Type                 ImageType `protobuf:"varint,2,opt,name=type,proto3,enum=protobuf.ImageType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ImageMessage) Reset()         { *m = ImageMessage{} }
func (m *ImageMessage) String() string { return proto.CompactTextString(m) }
func (*ImageMessage) ProtoMessage()    {}
func (*ImageMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{1}
}
func (m *ImageMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageMessage.Merge(m, src)
}
func (m *ImageMessage) XXX_Size() int {
	return m.Size()
}
func (m *ImageMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ImageMessage proto.InternalMessageInfo

func (m *ImageMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ImageMessage) GetType() ImageType {
	if m != nil {
		return m.Type
	}
	return ImageType_UNKNOWN_IMAGE_TYPE
}

type AudioMessage struct {
	Payload              []byte                 `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Type                 AudioMessage_AudioType `protobuf:"varint,2,opt,name=type,proto3,enum=protobuf.AudioMessage_AudioType" json:"type,omitempty"`
	DurationMs           uint64                 `protobuf:"varint,3,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *AudioMessage) Reset()         { *m = AudioMessage{} }
func (m *AudioMessage) String() string { return proto.CompactTextString(m) }
func (*AudioMessage) ProtoMessage()    {}
func (*AudioMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{2}
}
func (m *AudioMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudioMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AudioMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AudioMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioMessage.Merge(m, src)
}
func (m *AudioMessage) XXX_Size() int {
	return m.Size()
}
func (m *AudioMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioMessage.DiscardUnknown(m)
}

var xxx_messageInfo_AudioMessage proto.InternalMessageInfo

func (m *AudioMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *AudioMessage) GetType() AudioMessage_AudioType {
	if m != nil {
		return m.Type
	}
	return AudioMessage_UNKNOWN_AUDIO_TYPE
}

func (m *AudioMessage) GetDurationMs() uint64 {
	if m != nil {
		return m.DurationMs
	}
	return 0
}

type EditMessage struct {
	Clock uint64 `protobuf:"varint,1,opt,name=clock,proto3" json:"clock,omitempty"`
	// Text of the message
	Text      string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	ChatId    string `protobuf:"bytes,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId string `protobuf:"bytes,4,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Grant for community edit messages
	Grant []byte `protobuf:"bytes,5,opt,name=grant,proto3" json:"grant,omitempty"`
	// The type of message (public/one-to-one/private-group-chat)
	MessageType          MessageType `protobuf:"varint,6,opt,name=message_type,json=messageType,proto3,enum=protobuf.MessageType" json:"message_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *EditMessage) Reset()         { *m = EditMessage{} }
func (m *EditMessage) String() string { return proto.CompactTextString(m) }
func (*EditMessage) ProtoMessage()    {}
func (*EditMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{3}
}
func (m *EditMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditMessage.Merge(m, src)
}
func (m *EditMessage) XXX_Size() int {
	return m.Size()
}
func (m *EditMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EditMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EditMessage proto.InternalMessageInfo

func (m *EditMessage) GetClock() uint64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *EditMessage) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *EditMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *EditMessage) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *EditMessage) GetGrant() []byte {
	if m != nil {
		return m.Grant
	}
	return nil
}

func (m *EditMessage) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE_TYPE
}

type DeleteMessage struct {
	Clock     uint64 `protobuf:"varint,1,opt,name=clock,proto3" json:"clock,omitempty"`
	ChatId    string `protobuf:"bytes,2,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId string `protobuf:"bytes,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Grant for community delete messages
	Grant []byte `protobuf:"bytes,4,opt,name=grant,proto3" json:"grant,omitempty"`
	// The type of message (public/one-to-one/private-group-chat)
	MessageType          MessageType `protobuf:"varint,5,opt,name=message_type,json=messageType,proto3,enum=protobuf.MessageType" json:"message_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DeleteMessage) Reset()         { *m = DeleteMessage{} }
func (m *DeleteMessage) String() string { return proto.CompactTextString(m) }
func (*DeleteMessage) ProtoMessage()    {}
func (*DeleteMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{4}
}
func (m *DeleteMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMessage.Merge(m, src)
}
func (m *DeleteMessage) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMessage proto.InternalMessageInfo

func (m *DeleteMessage) GetClock() uint64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *DeleteMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *DeleteMessage) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *DeleteMessage) GetGrant() []byte {
	if m != nil {
		return m.Grant
	}
	return nil
}

func (m *DeleteMessage) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE_TYPE
}

type ChatMessage struct {
	// Lamport timestamp of the chat message
	Clock uint64 `protobuf:"varint,1,opt,name=clock,proto3" json:"clock,omitempty"`
	// Unix timestamps in milliseconds, currently not used as we use whisper as more reliable, but here
	// so that we don't rely on it
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Text of the message
	Text string `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	// Id of the message that we are replying to
	ResponseTo string `protobuf:"bytes,4,opt,name=response_to,json=responseTo,proto3" json:"response_to,omitempty"`
	// Ens name of the sender
	EnsName string `protobuf:"bytes,5,opt,name=ens_name,json=ensName,proto3" json:"ens_name,omitempty"`
	// Chat id, this field is symmetric for public-chats and private group chats,
	// but asymmetric in case of one-to-ones, as the sender will use the chat-id
	// of the received, while the receiver will use the chat-id of the sender.
	// Probably should be the concatenation of sender-pk & receiver-pk in alphabetical order
	ChatId string `protobuf:"bytes,6,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	// The type of message (public/one-to-one/private-group-chat)
	MessageType MessageType `protobuf:"varint,7,opt,name=message_type,json=messageType,proto3,enum=protobuf.MessageType" json:"message_type,omitempty"`
	// The type of the content of the message
	ContentType ChatMessage_ContentType `protobuf:"varint,8,opt,name=content_type,json=contentType,proto3,enum=protobuf.ChatMessage_ContentType" json:"content_type,omitempty"`
	// Types that are valid to be assigned to Payload:
	//	*ChatMessage_Sticker
	//	*ChatMessage_Image
	//	*ChatMessage_Audio
	//	*ChatMessage_Community
	Payload isChatMessage_Payload `protobuf_oneof:"payload"`
	// Grant for community chat messages
	Grant []byte `protobuf:"bytes,13,opt,name=grant,proto3" json:"grant,omitempty"`
	// Message author's display name, introduced in version 1
	DisplayName          string   `protobuf:"bytes,14,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChatMessage) Reset()         { *m = ChatMessage{} }
func (m *ChatMessage) String() string { return proto.CompactTextString(m) }
func (*ChatMessage) ProtoMessage()    {}
func (*ChatMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_263952f55fd35689, []int{5}
}
func (m *ChatMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatMessage.Merge(m, src)
}
func (m *ChatMessage) XXX_Size() int {
	return m.Size()
}
func (m *ChatMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ChatMessage proto.InternalMessageInfo

type isChatMessage_Payload interface {
	isChatMessage_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ChatMessage_Sticker struct {
	Sticker *StickerMessage `protobuf:"bytes,9,opt,name=sticker,proto3,oneof" json:"sticker,omitempty"`
}
type ChatMessage_Image struct {
	Image *ImageMessage `protobuf:"bytes,10,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type ChatMessage_Audio struct {
	Audio *AudioMessage `protobuf:"bytes,11,opt,name=audio,proto3,oneof" json:"audio,omitempty"`
}
type ChatMessage_Community struct {
	Community []byte `protobuf:"bytes,12,opt,name=community,proto3,oneof" json:"community,omitempty"`
}

func (*ChatMessage_Sticker) isChatMessage_Payload()   {}
func (*ChatMessage_Image) isChatMessage_Payload()     {}
func (*ChatMessage_Audio) isChatMessage_Payload()     {}
func (*ChatMessage_Community) isChatMessage_Payload() {}

func (m *ChatMessage) GetPayload() isChatMessage_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ChatMessage) GetClock() uint64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *ChatMessage) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ChatMessage) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ChatMessage) GetResponseTo() string {
	if m != nil {
		return m.ResponseTo
	}
	return ""
}

func (m *ChatMessage) GetEnsName() string {
	if m != nil {
		return m.EnsName
	}
	return ""
}

func (m *ChatMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *ChatMessage) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE_TYPE
}

func (m *ChatMessage) GetContentType() ChatMessage_ContentType {
	if m != nil {
		return m.ContentType
	}
	return ChatMessage_UNKNOWN_CONTENT_TYPE
}

func (m *ChatMessage) GetSticker() *StickerMessage {
	if x, ok := m.GetPayload().(*ChatMessage_Sticker); ok {
		return x.Sticker
	}
	return nil
}

func (m *ChatMessage) GetImage() *ImageMessage {
	if x, ok := m.GetPayload().(*ChatMessage_Image); ok {
		return x.Image
	}
	return nil
}

func (m *ChatMessage) GetAudio() *AudioMessage {
	if x, ok := m.GetPayload().(*ChatMessage_Audio); ok {
		return x.Audio
	}
	return nil
}

func (m *ChatMessage) GetCommunity() []byte {
	if x, ok := m.GetPayload().(*ChatMessage_Community); ok {
		return x.Community
	}
	return nil
}

func (m *ChatMessage) GetGrant() []byte {
	if m != nil {
		return m.Grant
	}
	return nil
}

func (m *ChatMessage) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ChatMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ChatMessage_Sticker)(nil),
		(*ChatMessage_Image)(nil),
		(*ChatMessage_Audio)(nil),
		(*ChatMessage_Community)(nil),
	}
}

func init() {
	proto.RegisterEnum("protobuf.AudioMessage_AudioType", AudioMessage_AudioType_name, AudioMessage_AudioType_value)
	proto.RegisterEnum("protobuf.ChatMessage_ContentType", ChatMessage_ContentType_name, ChatMessage_ContentType_value)
	proto.RegisterType((*StickerMessage)(nil), "protobuf.StickerMessage")
	proto.RegisterType((*ImageMessage)(nil), "protobuf.ImageMessage")
	proto.RegisterType((*AudioMessage)(nil), "protobuf.AudioMessage")
	proto.RegisterType((*EditMessage)(nil), "protobuf.EditMessage")
	proto.RegisterType((*DeleteMessage)(nil), "protobuf.DeleteMessage")
	proto.RegisterType((*ChatMessage)(nil), "protobuf.ChatMessage")
}

func init() { proto.RegisterFile("chat_message.proto", fileDescriptor_263952f55fd35689) }

var fileDescriptor_263952f55fd35689 = []byte{
	// 761 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x4d, 0x8f, 0xe3, 0x44,
	0x10, 0x8d, 0x13, 0x27, 0x8e, 0xcb, 0x99, 0xc8, 0xea, 0x5d, 0x76, 0x0d, 0x62, 0xb3, 0xd9, 0x08,
	0x89, 0x9c, 0x82, 0xb4, 0x2c, 0xd2, 0x4a, 0x9c, 0x3c, 0x89, 0x95, 0x31, 0x83, 0x9d, 0xd0, 0x76,
	0x80, 0xe1, 0x62, 0x79, 0xec, 0x66, 0x62, 0x4d, 0xfc, 0xa1, 0xb8, 0x23, 0x91, 0x2b, 0xbf, 0x82,
	0x3f, 0xc1, 0x95, 0x2b, 0x57, 0x8e, 0xdc, 0xb9, 0xa0, 0xe1, 0x8f, 0xa0, 0x6e, 0xc7, 0xb1, 0x27,
	0xd2, 0xce, 0xcc, 0x29, 0x55, 0x95, 0x7a, 0xcf, 0xaf, 0x5f, 0x75, 0x35, 0xa0, 0x60, 0xed, 0x53,
	0x2f, 0x26, 0x79, 0xee, 0xdf, 0x90, 0x49, 0xb6, 0x4d, 0x69, 0x8a, 0xba, 0xfc, 0xe7, 0x7a, 0xf7,
	0xf3, 0x27, 0x0a, 0x49, 0x76, 0x71, 0x5e, 0x94, 0x47, 0xef, 0xa1, 0xef, 0xd0, 0x28, 0xb8, 0x25,
	0x5b, 0xab, 0x68, 0x47, 0x08, 0xc4, 0xb5, 0x9f, 0xaf, 0x35, 0x61, 0x28, 0x8c, 0x65, 0xcc, 0x63,
	0x56, 0xcb, 0xfc, 0xe0, 0x56, 0x6b, 0x0e, 0x85, 0x71, 0x1b, 0xf3, 0x78, 0xf4, 0x1d, 0xf4, 0xcc,
	0xd8, 0xbf, 0x21, 0x25, 0x4e, 0x03, 0x29, 0xf3, 0xf7, 0x9b, 0xd4, 0x0f, 0x39, 0xb4, 0x87, 0xcb,
	0x14, 0x7d, 0x0e, 0x22, 0xdd, 0x67, 0x84, 0xa3, 0xfb, 0x6f, 0x9f, 0x4d, 0x4a, 0x25, 0x13, 0x8e,
	0x77, 0xf7, 0x19, 0xc1, 0xbc, 0x61, 0xf4, 0x87, 0x00, 0x3d, 0x7d, 0x17, 0x46, 0xe9, 0xe3, 0x9c,
	0xef, 0xee, 0x71, 0x0e, 0x2b, 0xce, 0x3a, 0xbe, 0x48, 0xaa, 0x0f, 0xa0, 0xd7, 0xa0, 0x84, 0xbb,
	0xad, 0x4f, 0xa3, 0x34, 0xf1, 0xe2, 0x5c, 0x6b, 0x0d, 0x85, 0xb1, 0x88, 0xa1, 0x2c, 0x59, 0xf9,
	0xe8, 0x2b, 0x90, 0x8f, 0x18, 0xf4, 0x02, 0xd0, 0xca, 0xbe, 0xb4, 0x17, 0x3f, 0xd8, 0x9e, 0xbe,
	0x9a, 0x99, 0x0b, 0xcf, 0xbd, 0x5a, 0x1a, 0x6a, 0x03, 0x49, 0xd0, 0xd2, 0xf5, 0xa9, 0x2a, 0xf0,
	0xc0, 0xc2, 0x6a, 0x73, 0xf4, 0xa7, 0x00, 0x8a, 0x11, 0x46, 0xb4, 0xd4, 0xfd, 0x1c, 0xda, 0xc1,
	0x26, 0x0d, 0x6e, 0xb9, 0x6a, 0x11, 0x17, 0x09, 0x73, 0x91, 0x92, 0x5f, 0x28, 0xd7, 0x2c, 0x63,
	0x1e, 0xa3, 0x97, 0x20, 0xf1, 0x61, 0x45, 0x21, 0x57, 0x23, 0xe3, 0x0e, 0x4b, 0xcd, 0x10, 0xbd,
	0x02, 0x38, 0x0c, 0x90, 0xfd, 0x27, 0xf2, 0xff, 0xe4, 0x43, 0xc5, 0x0c, 0xd9, 0x17, 0x6e, 0xb6,
	0x7e, 0x42, 0xb5, 0x36, 0xf7, 0xa5, 0x48, 0xd0, 0x7b, 0xe8, 0x95, 0x20, 0xee, 0x4e, 0x87, 0xbb,
	0xf3, 0x51, 0xe5, 0xce, 0x41, 0x20, 0xb7, 0x44, 0x89, 0xab, 0x64, 0xf4, 0xbb, 0x00, 0x67, 0x33,
	0xb2, 0x21, 0x94, 0x3c, 0x7c, 0x86, 0x9a, 0xde, 0xe6, 0x03, 0x7a, 0x5b, 0x1f, 0xd4, 0x2b, 0x3e,
	0xa4, 0xb7, 0xfd, 0x64, 0xbd, 0xbf, 0x76, 0x40, 0x99, 0xae, 0xfd, 0x47, 0x1c, 0xff, 0x14, 0x64,
	0x1a, 0xc5, 0x24, 0xa7, 0x7e, 0x9c, 0x71, 0xbd, 0x22, 0xae, 0x0a, 0xc7, 0x79, 0xb4, 0x6a, 0xf3,
	0x78, 0x0d, 0xca, 0x96, 0xe4, 0x59, 0x9a, 0xe4, 0xc4, 0xa3, 0xe9, 0xc1, 0x77, 0x28, 0x4b, 0x6e,
	0x8a, 0x3e, 0x86, 0x2e, 0x49, 0x72, 0x2f, 0xf1, 0xe3, 0x42, 0xae, 0x8c, 0x25, 0x92, 0xe4, 0xb6,
	0x1f, 0x93, 0xba, 0x37, 0x9d, 0x7b, 0xde, 0x9c, 0x1e, 0x53, 0x7a, 0xea, 0x31, 0xd1, 0x0c, 0x7a,
	0x41, 0x9a, 0x50, 0x92, 0xd0, 0x02, 0xd9, 0xe5, 0xc8, 0x37, 0x15, 0xb2, 0xe6, 0xc1, 0x64, 0x5a,
	0x74, 0x16, 0x2c, 0x41, 0x95, 0xa0, 0x77, 0x20, 0xe5, 0xc5, 0x92, 0x6b, 0xf2, 0x50, 0x18, 0x2b,
	0x6f, 0xb5, 0x8a, 0xe0, 0xfe, 0xf6, 0x5f, 0x34, 0x70, 0xd9, 0x8a, 0x26, 0xd0, 0x8e, 0xd8, 0x82,
	0x6a, 0xc0, 0x31, 0x2f, 0x4e, 0xf6, 0xb6, 0x42, 0x14, 0x6d, 0xac, 0xdf, 0x67, 0xbb, 0xa3, 0x29,
	0xa7, 0xfd, 0xf5, 0x9d, 0x64, 0xfd, 0xbc, 0x0d, 0x0d, 0x40, 0x0e, 0xd2, 0x38, 0xde, 0x25, 0x11,
	0xdd, 0x6b, 0x3d, 0x76, 0x2d, 0x2e, 0x1a, 0xb8, 0x2a, 0x55, 0x57, 0xe6, 0xac, 0x7e, 0x65, 0xde,
	0x40, 0x2f, 0x8c, 0xf2, 0x6c, 0xe3, 0xef, 0x8b, 0x19, 0xf4, 0xb9, 0xd3, 0xca, 0xa1, 0xc6, 0xe6,
	0x30, 0xfa, 0x47, 0x00, 0xa5, 0xe6, 0x05, 0xd2, 0xe0, 0x79, 0xb9, 0xc7, 0xd3, 0x85, 0xed, 0x1a,
	0xb6, 0x5b, 0x6e, 0x72, 0x1f, 0xc0, 0x35, 0x7e, 0x74, 0xbd, 0xe5, 0xb7, 0xba, 0x69, 0xab, 0x02,
	0x52, 0x40, 0x72, 0x5c, 0x73, 0x7a, 0x69, 0x60, 0xb5, 0x89, 0x00, 0x3a, 0x8e, 0xab, 0xbb, 0x2b,
	0x47, 0x6d, 0x21, 0x19, 0xda, 0x86, 0xb5, 0xf8, 0xc6, 0x54, 0x45, 0xf4, 0x12, 0x9e, 0xb9, 0x58,
	0xb7, 0x1d, 0x7d, 0xea, 0x9a, 0x0b, 0xc6, 0x68, 0x59, 0xba, 0x3d, 0x53, 0xdb, 0x68, 0x0c, 0x9f,
	0x39, 0x57, 0x8e, 0x6b, 0x58, 0x9e, 0x65, 0x38, 0x8e, 0x3e, 0x37, 0x8e, 0x5f, 0x5b, 0x62, 0xf3,
	0x7b, 0xdd, 0x35, 0xbc, 0x39, 0x5e, 0xac, 0x96, 0x6a, 0x87, 0xb1, 0x99, 0x96, 0x3e, 0x37, 0x54,
	0x89, 0x85, 0xfc, 0x6d, 0x51, 0xbb, 0xe8, 0x0c, 0x64, 0x46, 0xb6, 0xb2, 0x4d, 0xf7, 0x4a, 0x95,
	0xd9, 0xeb, 0x73, 0x42, 0x37, 0xd7, 0x97, 0x2a, 0x9c, 0xcb, 0xc7, 0x37, 0xf1, 0xfc, 0xd5, 0x5f,
	0x77, 0x03, 0xe1, 0xef, 0xbb, 0x81, 0xf0, 0xef, 0xdd, 0x40, 0xf8, 0xed, 0xbf, 0x41, 0xe3, 0x27,
	0x65, 0xf2, 0xc5, 0xd7, 0xa5, 0xed, 0xd7, 0x1d, 0x1e, 0x7d, 0xf9, 0x7f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xbb, 0xa1, 0x87, 0xc7, 0x0f, 0x06, 0x00, 0x00,
}

func (m *StickerMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StickerMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pack != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Pack))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AudioMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudioMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DurationMs != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.DurationMs))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EditMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MessageType != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Grant) > 0 {
		i -= len(m.Grant)
		copy(dAtA[i:], m.Grant)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Grant)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChatId) > 0 {
		i -= len(m.ChatId)
		copy(dAtA[i:], m.ChatId)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.ChatId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.Clock != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MessageType != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Grant) > 0 {
		i -= len(m.Grant)
		copy(dAtA[i:], m.Grant)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Grant)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChatId) > 0 {
		i -= len(m.ChatId)
		copy(dAtA[i:], m.ChatId)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.ChatId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Clock != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Grant) > 0 {
		i -= len(m.Grant)
		copy(dAtA[i:], m.Grant)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Grant)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ContentType != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.ContentType))
		i--
		dAtA[i] = 0x40
	}
	if m.MessageType != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ChatId) > 0 {
		i -= len(m.ChatId)
		copy(dAtA[i:], m.ChatId)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.ChatId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EnsName) > 0 {
		i -= len(m.EnsName)
		copy(dAtA[i:], m.EnsName)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.EnsName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResponseTo) > 0 {
		i -= len(m.ResponseTo)
		copy(dAtA[i:], m.ResponseTo)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.ResponseTo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Clock != 0 {
		i = encodeVarintChatMessage(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatMessage_Sticker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatMessage_Sticker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sticker != nil {
		{
			size, err := m.Sticker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ChatMessage_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatMessage_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ChatMessage_Audio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatMessage_Audio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Audio != nil {
		{
			size, err := m.Audio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChatMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ChatMessage_Community) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatMessage_Community) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Community != nil {
		i -= len(m.Community)
		copy(dAtA[i:], m.Community)
		i = encodeVarintChatMessage(dAtA, i, uint64(len(m.Community)))
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func encodeVarintChatMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovChatMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StickerMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.Pack != 0 {
		n += 1 + sovChatMessage(uint64(m.Pack))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImageMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovChatMessage(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AudioMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovChatMessage(uint64(m.Type))
	}
	if m.DurationMs != 0 {
		n += 1 + sovChatMessage(uint64(m.DurationMs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EditMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clock != 0 {
		n += 1 + sovChatMessage(uint64(m.Clock))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.Grant)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.MessageType != 0 {
		n += 1 + sovChatMessage(uint64(m.MessageType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clock != 0 {
		n += 1 + sovChatMessage(uint64(m.Clock))
	}
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.Grant)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.MessageType != 0 {
		n += 1 + sovChatMessage(uint64(m.MessageType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChatMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clock != 0 {
		n += 1 + sovChatMessage(uint64(m.Clock))
	}
	if m.Timestamp != 0 {
		n += 1 + sovChatMessage(uint64(m.Timestamp))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.ResponseTo)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.EnsName)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.MessageType != 0 {
		n += 1 + sovChatMessage(uint64(m.MessageType))
	}
	if m.ContentType != 0 {
		n += 1 + sovChatMessage(uint64(m.ContentType))
	}
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	l = len(m.Grant)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovChatMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChatMessage_Sticker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sticker != nil {
		l = m.Sticker.Size()
		n += 1 + l + sovChatMessage(uint64(l))
	}
	return n
}
func (m *ChatMessage_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovChatMessage(uint64(l))
	}
	return n
}
func (m *ChatMessage_Audio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovChatMessage(uint64(l))
	}
	return n
}
func (m *ChatMessage_Community) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Community != nil {
		l = len(m.Community)
		n += 1 + l + sovChatMessage(uint64(l))
	}
	return n
}

func sovChatMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChatMessage(x uint64) (n int) {
	return sovChatMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StickerMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pack", wireType)
			}
			m.Pack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pack |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChatMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ImageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChatMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AudioMessage_AudioType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationMs", wireType)
			}
			m.DurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationMs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChatMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grant", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grant = append(m.Grant[:0], dAtA[iNdEx:postIndex]...)
			if m.Grant == nil {
				m.Grant = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChatMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grant", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grant = append(m.Grant[:0], dAtA[iNdEx:postIndex]...)
			if m.Grant == nil {
				m.Grant = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChatMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= ChatMessage_ContentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StickerMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ChatMessage_Sticker{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImageMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ChatMessage_Image{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AudioMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &ChatMessage_Audio{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Community", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Payload = &ChatMessage_Community{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grant", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grant = append(m.Grant[:0], dAtA[iNdEx:postIndex]...)
			if m.Grant == nil {
				m.Grant = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChatMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChatMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChatMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChatMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChatMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChatMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChatMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChatMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChatMessage = fmt.Errorf("proto: unexpected end of group")
)
